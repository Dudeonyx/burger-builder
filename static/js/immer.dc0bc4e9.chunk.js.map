{"version":3,"sources":["../node_modules/immer/dist/immer.module.js"],"names":["__webpack_require__","r","__webpack_exports__","process","d","produce","applyPatches$1","nothing","setAutoFreeze","setUseProxies","original","isProxy","_typeof","Symbol","iterator","obj","constructor","prototype","generatePatches","state","basepath","patches","inversePatches","baseValue","resultValue","Array","isArray","shared","Math","min","length","i","assigned","path","concat","push","op","value","_i","_path","_i2","_path2","generateArrayPatches","each","key","assignedValue","origValue","generateObjectPatches","NOTHING","Object","defineProperty","enumerable","configurable","writable","PROXY_STATE","RETURNED_AND_MODIFIED_ERROR","autoFreeze","name","useProxies","Proxy","Reflect","enableAutoFreeze","isProxyable","proto","getPrototypeOf","base","assign","target","has","shallowCopy","slice","undefined","__proto__","create","cb","thing","prop","hasOwnProperty","call","finalize","modified","finalized","copy","result","_generatePatches","freeze","finalizeObject","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","get","createProxy","_value","source","ownKeys","set","isUnchanged","markChanged","deleteProperty","getOwnPropertyDescriptor","owner","descriptor","Error","setPrototypeOf","arrayTraps","parentState","createState","proxy","revocable","fn","arguments","apply","this","isNaN","parseInt","descriptors","states","source$1","hasCopy","markChanged$1","prepareCopy","createProxy$1","assertUnfinished","finalizing","_get","_set","finished","createState$1","JSON","stringify","hasObjectChanges","keys","hasArrayChanges","produceEs5","baseState","producer","patchListener","prevStates","rootProxy","returnValue","_","markChangesRecursively","object","forEach","markChangesSweep","initialState","recipe","_len","args","_key","draft","normalizeResult","_returnValue","previousProxies","p","revoke","produceProxy","patch","_i3","join"],"mappings":"0FAAAA,EAAAC,EAAAC,GAAA,SAAAC,GAAAH,EAAAI,EAAAF,EAAA,4BAAAG,IAAAL,EAAAI,EAAAF,EAAA,iCAAAI,IAAAN,EAAAI,EAAAF,EAAA,4BAAAK,IAAAP,EAAAI,EAAAF,EAAA,kCAAAM,IAAAR,EAAAI,EAAAF,EAAA,kCAAAO,IAAAT,EAAAI,EAAAF,EAAA,6BAAAQ,IAAAV,EAAAI,EAAAF,EAAA,4BAAAS,IAAA,IAAAC,EAAA,oBAAAC,QAAA,kBAAAA,OAAAC,SAAA,SAAAC,GACA,cAAAA,GACC,SAAAA,GACD,OAAAA,GAAA,oBAAAF,QAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAAI,UAAA,gBAAAF,GAkBA,SAAAG,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAH,IAAAI,MAAAC,QAAAH,GAGA,SAAAJ,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAGA,IAFA,IAAAG,EAAAC,KAAAC,IAAAN,EAAAO,OAAAN,EAAAM,QAEAC,EAAA,EAAiBA,EAAAJ,EAAYI,IAC7B,GAAAZ,EAAAa,SAAAD,IAAAR,EAAAQ,KAAAP,EAAAO,GAAA,CACA,IAAAE,EAAAb,EAAAc,OAAAH,GACAV,EAAAc,KAAA,CACAC,GAAA,UACAH,OACAI,MAAAb,EAAAO,KAEAT,EAAAa,KAAA,CACAC,GAAA,UACAH,OACAI,MAAAd,EAAAQ,KAKA,GAAAJ,EAAAH,EAAAM,OAAA,CAEA,QAAAQ,EAAAX,EAAyBW,EAAAd,EAAAM,OAAyBQ,IAAA,CAClD,IAAAC,EAAAnB,EAAAc,OAAAI,GAEAjB,EAAAc,KAAA,CACAC,GAAA,MACAH,KAAAM,EACAF,MAAAb,EAAAc,KAIAhB,EAAAa,KAAA,CACAC,GAAA,UACAH,KAAAb,EAAAc,OAAA,UACAG,MAAAd,EAAAO,cAEG,GAAAH,EAAAJ,EAAAO,OAAA,CAEHT,EAAAc,KAAA,CACAC,GAAA,UACAH,KAAAb,EAAAc,OAAA,UACAG,MAAAb,EAAAM,SAGA,QAAAU,EAAAb,EAA0Ba,EAAAjB,EAAAO,OAAwBU,IAAA,CAClD,IAAAC,EAAArB,EAAAc,OAAAM,GAEAlB,EAAAa,KAAA,CACAC,GAAA,MACAH,KAAAQ,EACAJ,MAAAd,EAAAiB,OArDAE,CAAAvB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GA2DA,SAAAL,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAmB,EAAAxB,EAAAa,SAAA,SAAAY,EAAAC,GACA,IAAAC,EAAAvB,EAAAqB,GACAP,EAAAb,EAAAoB,GACAR,EAAAS,EAAAD,KAAArB,EAAA,yBACA,GAAAuB,IAAAvB,GAAA,YAAAa,EAAA,CACA,IAAAH,EAAAb,EAAAc,OAAAU,GACAvB,EAAAc,KAAA,WAAAC,EAAA,CACAA,KACAH,QACK,CACLG,KACAH,OACAI,UAEAf,EAAAa,KAAA,QAAAC,EAAA,CACAA,GAAA,SACAH,QACK,WAAAG,EAAA,CACLA,GAAA,MACAH,OACAI,MAAAS,GACK,CACLV,GAAA,UACAH,OACAI,MAAAS,OApFoIC,CAAA5B,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,IAiIpI,IAjJAT,EAAA6B,EAAAP,EAiJAW,EAAA,qBAAAnC,cAAA,kBAjJAwB,GAiJyF,GAjJzFO,EAiJyF,mBAjJzF7B,EAiJA,IA/IAkC,OAAAC,eAAAnC,EAAA6B,EAAA,CACAP,QACAc,YAAA,EACAC,cAAA,EACAC,UAAA,IAGAtC,EAAA6B,GAAAP,EAGAtB,GAsIAuC,EAAA,qBAAAzC,cAAA,sCACA0C,EAAA,oHAIA,IACAC,IADA,qBAAArD,GAAyE,mBAFzE,aAEyEsD,MAEzEC,EAAA,qBAAAC,OAAA,qBAAAC,QAUA,SAAApD,EAAAqD,GACAL,EAAAK,EAGA,SAAApD,EAAA4B,GACAqB,EAAArB,EAOA,SAAA1B,EAAA0B,GACA,QAAAA,OAAAiB,GAGA,SAAAQ,EAAAzB,GACA,IAAAA,EAAA,SACA,oCAAAA,EAAA,YAAAzB,EAAAyB,IAAA,SACA,GAAAZ,MAAAC,QAAAW,GAAA,SACA,IAAA0B,EAAAd,OAAAe,eAAA3B,GACA,cAAA0B,OAAAd,OAAAhC,UAWA,SAAAP,EAAA2B,GACA,GAAAA,KAAAiB,GACA,OAAAjB,EAAAiB,GAAAW,KAKA,IAAAC,EAAAjB,OAAAiB,QAAA,SAAAC,EAAA9B,GACA,QAAAO,KAAAP,EACA+B,EAAA/B,EAAAO,KACAuB,EAAAvB,GAAAP,EAAAO,IAIA,OAAAuB,GAGA,SAAAE,EAAAhC,GACA,GAAAZ,MAAAC,QAAAW,GAAA,OAAAA,EAAAiC,QACA,IAAAH,OAAAI,IAAAlC,EAAAmC,UAAAvB,OAAAwB,OAAA,SACA,OAAAP,EAAAC,EAAA9B,GAGA,SAAAM,EAAAN,EAAAqC,GACA,GAAAjD,MAAAC,QAAAW,GACA,QAAAN,EAAA,EAAmBA,EAAAM,EAAAP,OAAkBC,IACrC2C,EAAA3C,EAAAM,EAAAN,SAGA,QAAAa,KAAAP,EACAqC,EAAA9B,EAAAP,EAAAO,IAKA,SAAAwB,EAAAO,EAAAC,GACA,OAAA3B,OAAAhC,UAAA4D,eAAAC,KAAAH,EAAAC,GAIA,SAAAG,EAAAd,EAAAhC,EAAAZ,EAAAC,GACA,GAAAX,EAAAsD,GAAA,CACA,IAAA9C,EAAA8C,EAAAX,GAEA,QAAAnC,EAAA6D,SAAA,CACA,QAAA7D,EAAA8D,UAAA,OAAA9D,EAAA+D,KACA/D,EAAA8D,WAAA,EACA,IAAAE,EAYA,SAAAD,EAAA/D,EAAAc,EAAAZ,EAAAC,GACA,IAAA2C,EAAA9C,EAAA8C,KAUA,OATAtB,EAAAuC,EAAA,SAAAN,EAAAvC,GACA,GAAAA,IAAA4B,EAAAW,GAAA,CAGA,IAAAQ,EAAA/D,IAAA+C,EAAAjD,EAAAa,SAAA4C,GAEAM,EAAAN,GAAAG,EAAA1C,EAAA+C,GAAAnD,EAAAC,OAAA0C,GAAAQ,GAAA/D,EAAAC,MA3EAe,EA8EA6C,EA7EA1B,GACAP,OAAAoC,OAAAhD,GAGAA,EALA,IAAAA,EAuDAiD,CAAA5B,EAAAvC,EAAA+D,KAAA/D,EAAA+D,KAAAb,EAAAJ,GAAA9C,EAAAc,EAAAZ,EAAAC,GAEA,OADAJ,EAAAC,EAAAc,EAAAZ,EAAAC,EAAAH,EAAA8C,KAAAkB,GACAA,EAEA,OAAAhE,EAAA8C,KAKA,OAiBA,SAAAsB,EAAAC,GAGA,IAAA1B,EAAA0B,GAAA,OACA,GAAAvC,OAAAwC,SAAAD,GAAA,OACA7C,EAAA6C,EAAA,SAAAzD,EAAA2D,GACA/E,EAAA+E,GACAF,EAAAzD,GAAAgD,EAAAW,GACKH,EAAAG,KA1BLH,CAAAtB,GACAA,EA6BA,SAAA0B,EAAAC,EAAAC,GAEA,OAAAD,IAAAC,EACA,IAAAD,GAAA,EAAAA,IAAA,EAAAC,EAEAD,OAAAC,MAKA,IAAAC,EAAA,KACAC,EAAA,CACAC,IAmDA,SAAA7E,EAAAyD,GACA,GAAAA,IAAAtB,EAAA,OAAAnC,EAEA,GAAAA,EAAA6D,SAAA,CACA,IAAA3C,EAAAlB,EAAA+D,KAAAN,GACA,OAAAvC,IAAAlB,EAAA8C,KAAAW,IAAAd,EAAAzB,GAEAlB,EAAA+D,KAAAN,GAAAqB,EAAA9E,EAAAkB,GACAA,EAEA,GAAA+B,EAAAjD,EAAA2E,QAAAlB,GAAA,OAAAzD,EAAA2E,QAAAlB,GACA,IAAAsB,EAAA/E,EAAA8C,KAAAW,GACA,OAAAjE,EAAAuF,IAAApC,EAAAoC,GAAA/E,EAAA2E,QAAAlB,GAAAqB,EAAA9E,EAAA+E,GACAA,GA/DA9B,IAAA,SAAAD,EAAAS,GACA,OAAAA,KAAAuB,EAAAhC,IAEAiC,QAAA,SAAAjC,GACA,OAAAP,QAAAwC,QAAAD,EAAAhC,KAEAkC,IA6DA,SAAAlF,EAAAyD,EAAAvC,GACA,IAAAlB,EAAA6D,SAAA,CAIA,IAAAsB,EAAAjE,EAAAsD,EAAAxE,EAAA8C,KAAAW,GAAAvC,QAAAlB,EAAA2E,QAAAlB,GAAAe,EAAAxE,EAAA8C,KAAAW,GAAAvC,IAAAuC,KAAAzD,EAAA8C,KACA,GAAAqC,EAAA,SACAC,EAAApF,GAKA,OAFAA,EAAAa,SAAA4C,IAAA,EACAzD,EAAA+D,KAAAN,GAAAvC,GACA,GAxEAmE,eA2EA,SAAArF,EAAAyD,GAIA,OAHAzD,EAAAa,SAAA4C,IAAA,EACA2B,EAAApF,UACAA,EAAA+D,KAAAN,IACA,GA9EA6B,yBAiFA,SAAAtF,EAAAyD,GACA,IAAA8B,EAAAvF,EAAA6D,SAAA7D,EAAA+D,KAAAd,EAAAjD,EAAA2E,QAAAlB,GAAAzD,EAAA2E,QAAA3E,EAAA8C,KACA0C,EAAA/C,QAAA6C,yBAAAC,EAAA9B,IACA+B,GAAAlF,MAAAC,QAAAgF,IAAA,WAAA9B,IAAA+B,EAAAvD,cAAA,GACA,OAAAuD,GApFAzD,eAuFA,WACA,UAAA0D,MAAA,iEAvFAC,eAAA,WACA,UAAAD,MAAA,gDAGAE,EAAA,GAgCA,SAAAX,EAAAhF,GACA,WAAAA,EAAA6D,SAAA7D,EAAA+D,KAAA/D,EAAA8C,KAqDA,SAAAsC,EAAApF,GACAA,EAAA6D,WACA7D,EAAA6D,UAAA,EACA7D,EAAA+D,KAAAb,EAAAlD,EAAA8C,MAEAC,EAAA/C,EAAA+D,KAAA/D,EAAA2E,SAEA3E,EAAAqE,QAAAe,EAAApF,EAAAqE,SAKA,SAAAS,EAAAc,EAAA9C,GACA,GAAAtD,EAAAsD,GAAA,UAAA2C,MAAA,0BACA,IAAAzF,EAlFA,SAAAqE,EAAAvB,GACA,OACAe,UAAA,EAEAhD,SAAA,GAEAiD,WAAA,EACAO,SACAvB,OACAiB,UAAAX,EACAuB,QAAA,IAwEAkB,CAAAD,EAAA9C,GACAgD,EAAAxF,MAAAC,QAAAuC,GAAAN,MAAAuD,UAAA,CAAA/F,GAAA2F,GAAAnD,MAAAuD,UAAA/F,EAAA4E,GAEA,OADAD,EAAA3D,KAAA8E,GACAA,QAtGAtE,EAAAoD,EAAA,SAAAnD,EAAAuE,GACAL,EAAAlE,GAAA,WAEA,OADAwE,UAAA,GAAAA,UAAA,MACAD,EAAAE,MAAAC,KAAAF,cAIAN,EAAAN,eAAA,SAAArF,EAAAyD,GACA,GAAA2C,MAAAC,SAAA5C,IAAA,UAAAgC,MAAA,2DAAAhC,GACA,OAAAmB,EAAAS,eAAA1B,KAAAwC,KAAAnG,EAAA,GAAAyD,IAGAkC,EAAAT,IAAA,SAAAlF,EAAAyD,EAAAvC,GACA,cAAAuC,GAAA2C,MAAAC,SAAA5C,IAAA,UAAAgC,MAAA,oEAAAhC,GACA,OAAAmB,EAAAM,IAAAvB,KAAAwC,KAAAnG,EAAA,GAAAyD,EAAAvC,IA2IA,IAAAoF,EAAA,GACAC,EAAA,KAkBA,SAAAC,EAAAxG,GACA,OAAAA,EAAAyG,QAAAzG,EAAA+D,KAAA/D,EAAA8C,KA8BA,SAAA4D,EAAA1G,GACAA,EAAA6D,WACA7D,EAAA6D,UAAA,EACA7D,EAAAqE,QAAAqC,EAAA1G,EAAAqE,SAIA,SAAAsC,EAAA3G,GACAA,EAAAyG,UACAzG,EAAAyG,SAAA,EACAzG,EAAA+D,KAAAb,EAAAlD,EAAA8C,OAIA,SAAA8D,EAAAvC,EAAAvB,GACA,IAAAgD,EAAA5C,EAAAJ,GACAtB,EAAAsB,EAAA,SAAAlC,GASA,IAAA6C,EARA3B,OAAAC,eAAA+D,EAAA,GAAAlF,EASA0F,EADA7C,EARA,GAAA7C,KASA0F,EAAA7C,GAAA,CACAxB,cAAA,EACAD,YAAA,EACA6C,IAAA,WACA,OAzDA,SAAA7E,EAAAyD,GACAoD,EAAA7G,GACA,IAAAkB,EAAAsF,EAAAxG,GAAAyD,GAEA,OAAAzD,EAAA8G,YAAA5F,IAAAlB,EAAA8C,KAAAW,IAAAd,EAAAzB,IAGAyF,EAAA3G,GACAA,EAAA+D,KAAAN,GAAAmD,EAAA5G,EAAAkB,IAGAA,EA8CA6F,CAAAZ,KAAAhE,GAAAsB,IAEAyB,IAAA,SAAAhE,IA7CA,SAAAlB,EAAAyD,EAAAvC,GAIA,GAHA2F,EAAA7G,GACAA,EAAAa,SAAA4C,IAAA,GAEAzD,EAAA6D,SAAA,CACA,GAAAW,EAAAgC,EAAAxG,GAAAyD,GAAAvC,GAAA,OACAwF,EAAA1G,GACA2G,EAAA3G,GAGAA,EAAA+D,KAAAN,GAAAvC,EAoCA8F,CAAAb,KAAAhE,GAAAsB,EAAAvC,SAdA,IAkLA8B,EAAAS,EAAAvC,EAlLAlB,EAlEA,SAAAqE,EAAAyB,EAAAhD,GACA,OACAe,UAAA,EACAhD,SAAA,GAEA4F,SAAA,EACApC,SACAvB,OACAgD,QACA/B,UAAAX,EACA6D,UAAA,EACAH,YAAA,EACAhD,WAAA,GAsDAoD,CAAA7C,EAAAyB,EAAAhD,GAGA,OA+KAE,EAjLA8C,EAiLArC,EAjLAtB,EAiLAjB,EAjLAlB,EAkLA8B,OAAAC,eAAAiB,EAAAS,EAAA,CACAvC,QACAc,YAAA,EACAE,UAAA,IApLAqE,EAAAvF,KAAAhB,GACA8F,EAgBA,SAAAe,EAAA7G,GACA,QAAAA,EAAAiH,SAAA,UAAAxB,MAAA,uHAAA0B,KAAAC,UAAApH,EAAA+D,MAAA/D,EAAA8C,OAsEA,SAAAuE,EAAArH,GAOA,IANA,IAAA8C,EAAA9C,EAAA8C,KACAgD,EAAA9F,EAAA8F,MAGAwB,EAAAxF,OAAAwF,KAAAxB,GAEAlF,EAAA0G,EAAA3G,OAAA,EAA+BC,GAAA,EAAQA,IAEvC,QAAAwC,IAAAN,EAAAwE,EAAA1G,MAAAqC,EAAAH,EAAAwE,EAAA1G,IACA,SAMA,OAAA0G,EAAA3G,SAAAmB,OAAAwF,KAAAxE,GAAAnC,OAGA,SAAA4G,EAAAvH,GACA,IAAA8F,EAAA9F,EAAA8F,MACA,GAAAA,EAAAnF,SAAAX,EAAA8C,KAAAnC,OAAA,SAQA,IAAA6E,EAAA1D,OAAAwD,yBAAAQ,IAAAnF,OAAA,GAEA,SAAA6E,KAAAX,KAKA,SAAA2C,EAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAArB,EACAA,EAAA,GACA,IAAArG,EAAAyH,GAAA,GACAxH,EAAAwH,GAAA,GAEA,IAEA,IAAAE,EAAAjB,OAAAxD,EAAAqE,GAEAK,EAAAJ,EAAA/D,KAAAkE,KAEArG,EAAA+E,EAAA,SAAAwB,EAAA/H,GACAA,EAAA8G,YAAA,IAEA,IAAA9C,OAAA,EAEA,QAAAZ,IAAA0E,OAAAD,EAAA,CAEA,GAAAA,EAAA1F,GAAA0B,SAAA,UAAA4B,MAAArD,GACA4B,EAAAJ,EAAAkE,GAEA5H,IACAA,EAAAc,KAAA,CACAC,GAAA,UACAH,KAAA,GACAI,MAAA8C,IAEA7D,EAAAa,KAAA,CACAC,GAAA,UACAH,KAAA,GACAI,MAAAuG,UAIAE,GAxHA,SAAAK,EAAAC,GACA,GAAAA,GAAA,iCAAAA,EAAA,YAAAxI,EAAAwI,IAAA,CACA,IAAAjI,EAAAiI,EAAA9F,GACA,GAAAnC,EAAA,CACA,IAAA8F,EAAA9F,EAAA8F,MACAhD,EAAA9C,EAAA8C,KACAjC,EAAAb,EAAAa,SAEA,GAAAP,MAAAC,QAAA0H,IAoBG,GAAAV,EAAAvH,GAAA,CAIH,GAHA0G,EAAA1G,GACAa,EAAAF,QAAA,EAEAmF,EAAAnF,OAAAmC,EAAAnC,OACA,QAAAC,EAAAkF,EAAAnF,OAAgCC,EAAAkC,EAAAnC,OAAiBC,IACjDC,EAAAD,IAAA,OAGA,QAAAO,EAAA2B,EAAAnC,OAAgCQ,EAAA2E,EAAAnF,OAAmBQ,IACnDN,EAAAM,IAAA,EAIA,QAAAE,EAAA,EAAqBA,EAAAyE,EAAAnF,OAAoBU,SAEzC+B,IAAAvC,EAAAQ,IAAA2G,EAAAlC,EAAAzE,UAlCAS,OAAAwF,KAAAxB,GAAAoC,QAAA,SAAAzG,QAEA2B,IAAAN,EAAArB,IAAAwB,EAAAH,EAAArB,GAGOZ,EAAAY,IAEPuG,EAAAlC,EAAArE,KAJAZ,EAAAY,IAAA,EACAiF,EAAA1G,MAOA8B,OAAAwF,KAAAxE,GAAAoF,QAAA,SAAAzG,QAEA2B,IAAA0C,EAAArE,IAAAwB,EAAA6C,EAAArE,KACAZ,EAAAY,IAAA,EACAiF,EAAA1G,QA+FAgI,CAAAH,GAvIA,WAIA,QAAAjH,EAAA2F,EAAA5F,OAAA,EAAiCC,GAAA,EAAQA,IAAA,CACzC,IAAAZ,EAAAuG,EAAA3F,IAEA,IAAAZ,EAAA6D,WACAvD,MAAAC,QAAAP,EAAA8C,MACAyE,EAAAvH,IAAA0G,EAAA1G,GACOqH,EAAArH,IAAA0G,EAAA1G,KA8HPmI,GAEAnE,EAAAJ,EAAAiE,EAAA,GAAA3H,EAAAC,GAQA,OAJAqB,EAAA+E,EAAA,SAAAwB,EAAA/H,GACAA,EAAAiH,UAAA,IAEAU,KAAAzH,EAAAC,GACA6D,EACG,QACHuC,EAAAqB,GAwBA,SAAA1I,EAAAuI,EAAAC,EAAAC,GAEA,GAAA1B,UAAAtF,OAAA,GAAAsF,UAAAtF,OAAA,YAAA8E,MAAA,yCAAAQ,UAAAtF,QAEA,uBAAA8G,GAAA,oBAAAC,EAAA,CACA,IAAAU,EAAAV,EACAW,EAAAZ,EACA,kBACA,QAAAa,EAAArC,UAAAtF,OAAA4H,EAAAjI,MAAAgI,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAwFA,EAAAF,EAAaE,IACrGD,EAAAC,EAAA,GAAAvC,UAAAuC,GAIA,OAAAtJ,EADA+G,UAAAtF,OAAA,QAAAyC,IAAA6C,UAAA,GAAAA,UAAA,GAAAmC,EACA,SAAAK,GACA,OAAAJ,EAAA1E,KAAAuC,MAAAmC,EAAA,CAAAI,KAAA1H,OAAAwH,OAOA,uBAAAb,EAAA,UAAAjC,MAAA,4FACA,QAAArC,IAAAuE,GAAA,oBAAAA,EAAA,UAAAlC,MAAA,oEAGA,IAAA9C,EAAA8E,GAAA,CACA,IAAAK,EAAAJ,EAAAD,GACA,YAAArE,IAAA0E,EAAAL,EAAAiB,EAAAZ,GAIA,GAAAtI,EAAAiI,GAAA,CACA,IAAAkB,EAAAjB,EAAA/D,KAAA8D,KAEA,YAAArE,IAAAuF,EAAAlB,EAAAiB,EAAAC,GAGA,OAAAD,EAjlBAnG,EAiPA,SAAAkF,EAAAC,EAAAC,GACA,IAAAiB,EAAAjE,EACAA,EAAA,GACA,IAAAzE,EAAAyH,GAAA,GACAxH,EAAAwH,GAAA,GAEA,IAEA,IAAAE,EAAA/C,OAAA1B,EAAAqE,GAEAK,EAAAJ,EAAA/D,KAAAkE,KAEA7D,OAAA,EAEA,QAAAZ,IAAA0E,OAAAD,EAAA,CAEA,GAAAA,EAAA1F,GAAA0B,SAAA,UAAA4B,MAAArD,GAEA4B,EAAAJ,EAAAkE,GAEA5H,IACAA,EAAAc,KAAA,CACAC,GAAA,UACAH,KAAA,GACAI,MAAA8C,IAEA7D,EAAAa,KAAA,CACAC,GAAA,UACAH,KAAA,GACAI,MAAAuG,UAIAzD,EAAAJ,EAAAiE,EAAA,GAAA3H,EAAAC,GAQA,OAJAqB,EAAAmD,EAAA,SAAAoD,EAAAc,GACA,OAAAA,EAAAC,WAEAnB,KAAAzH,EAAAC,GACA6D,EACG,QACHW,EAAAiE,GAqTAG,CAAAtB,EAAAC,EAAAC,GAAAH,EAAAC,EAAAC,EAAAC,IAGA,SAAAe,EAAA1E,GACA,OAAAA,IAAAnC,OAAAuB,EAAAY,EAGA,IAAA7E,EAAAD,EA3pBA,SAAAuJ,EAAAvI,GACA,QAAAU,EAAA,EAAiBA,EAAAV,EAAAS,OAAoBC,IAAA,CACrC,IAAAoI,EAAA9I,EAAAU,GACAE,EAAAkI,EAAAlI,KAEA,OAAAA,EAAAH,QAAA,YAAAqI,EAAA/H,GACAwH,EAAAO,EAAA9H,UACK,CAGL,IAFA,IAAA4B,EAAA2F,EAEAQ,EAAA,EAAuBA,EAAAnI,EAAAH,OAAA,EAAuBsI,IAE9C,KADAnG,IAAAhC,EAAAmI,MACA,iCAAAnG,EAAA,YAAArD,EAAAqD,IAAA,UAAA2C,MAAA,6CAAA3E,EAAAoI,KAAA,MAGA,IAAAzH,EAAAX,IAAAH,OAAA,GAEA,OAAAqI,EAAA/H,IACA,cACA,UAEA6B,EAAArB,GAAAuH,EAAA9H,MACA,MAEA,aACA,GAAAZ,MAAAC,QAAAuC,GAAA,CACA,GAAArB,IAAAqB,EAAAnC,OAAA,EAA0D,UAAA8E,MAAA,2DAAAhE,EAAA,aAAAqB,EAAAnC,QAA1DmC,EAAAnC,QAAA,cACWmC,EAAArB,GAEX,MAEA,QACA,UAAAgE,MAAA,gCAAAuD,EAAA/H,MAKA,OAAAwH,IAunBArJ,EAAAyC,EAEe9C,EAAA","file":"static/js/immer.dc0bc4e9.chunk.js","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nfunction generatePatches(state, basepath, patches, inversePatches, baseValue, resultValue) {\n  if (patches) if (Array.isArray(baseValue)) generateArrayPatches(state, basepath, patches, inversePatches, baseValue, resultValue);else generateObjectPatches(state, basepath, patches, inversePatches, baseValue, resultValue);\n}\n\nfunction generateArrayPatches(state, basepath, patches, inversePatches, baseValue, resultValue) {\n  var shared = Math.min(baseValue.length, resultValue.length);\n\n  for (var i = 0; i < shared; i++) {\n    if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n      var path = basepath.concat(i);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: resultValue[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: baseValue[i]\n      });\n    }\n  }\n\n  if (shared < resultValue.length) {\n    // stuff was added\n    for (var _i = shared; _i < resultValue.length; _i++) {\n      var _path = basepath.concat(_i);\n\n      patches.push({\n        op: \"add\",\n        path: _path,\n        value: resultValue[_i]\n      });\n    }\n\n    inversePatches.push({\n      op: \"replace\",\n      path: basepath.concat(\"length\"),\n      value: baseValue.length\n    });\n  } else if (shared < baseValue.length) {\n    // stuff was removed\n    patches.push({\n      op: \"replace\",\n      path: basepath.concat(\"length\"),\n      value: resultValue.length\n    });\n\n    for (var _i2 = shared; _i2 < baseValue.length; _i2++) {\n      var _path2 = basepath.concat(_i2);\n\n      inversePatches.push({\n        op: \"add\",\n        path: _path2,\n        value: baseValue[_i2]\n      });\n    }\n  }\n}\n\nfunction generateObjectPatches(state, basepath, patches, inversePatches, baseValue, resultValue) {\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = baseValue[key];\n    var value = resultValue[key];\n    var op = !assignedValue ? \"remove\" : key in baseValue ? \"replace\" : \"add\";\n    if (origValue === baseValue && op === \"replace\") return;\n    var path = basepath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  for (var i = 0; i < patches.length; i++) {\n    var patch = patches[i];\n    var path = patch.path;\n\n    if (path.length === 0 && patch.op === \"replace\") {\n      draft = patch.value;\n    } else {\n      var base = draft;\n\n      for (var _i3 = 0; _i3 < path.length - 1; _i3++) {\n        base = base[path[_i3]];\n        if (!base || (typeof base === \"undefined\" ? \"undefined\" : _typeof(base)) !== \"object\") throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      }\n\n      var key = path[path.length - 1];\n\n      switch (patch.op) {\n        case \"replace\":\n        case \"add\":\n          // TODO: add support is not extensive, it does not support insertion or `-` atm!\n          base[key] = patch.value;\n          break;\n\n        case \"remove\":\n          if (Array.isArray(base)) {\n            if (key === base.length - 1) base.length -= 1;else throw new Error(\"Remove can only remove the last key of an array, index: \" + key + \", length: \" + base.length);\n          } else delete base[key];\n\n          break;\n\n        default:\n          throw new Error(\"Unsupported patch operation: \" + patch.op);\n      }\n    }\n  }\n\n  return draft;\n}\n\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : defineProperty({}, \"immer-nothing\", true);\nvar PROXY_STATE = typeof Symbol !== \"undefined\" ? Symbol(\"immer-proxy-state\") : \"__$immer_state\";\nvar RETURNED_AND_MODIFIED_ERROR = \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\";\n\nfunction verifyMinified() {}\n\nvar inProduction = typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\" || verifyMinified.name !== \"verifyMinified\";\nvar autoFreeze = !inProduction;\nvar useProxies = typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\";\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\n\nfunction setAutoFreeze(enableAutoFreeze) {\n  autoFreeze = enableAutoFreeze;\n}\n\nfunction setUseProxies(value) {\n  useProxies = value;\n}\n\nfunction getUseProxies() {\n  return useProxies;\n}\n\nfunction isProxy(value) {\n  return !!value && !!value[PROXY_STATE];\n}\n\nfunction isProxyable(value) {\n  if (!value) return false;\n  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n  if (Array.isArray(value)) return true;\n  var proto = Object.getPrototypeOf(value);\n  return proto === null || proto === Object.prototype;\n}\n\nfunction freeze(value) {\n  if (autoFreeze) {\n    Object.freeze(value);\n  }\n\n  return value;\n}\n\nfunction original(value) {\n  if (value && value[PROXY_STATE]) {\n    return value[PROXY_STATE].base;\n  } // otherwise return undefined\n\n}\n\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\n\nfunction shallowCopy(value) {\n  if (Array.isArray(value)) return value.slice();\n  var target = value.__proto__ === undefined ? Object.create(null) : {};\n  return assign(target, value);\n}\n\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      cb(i, value[i]);\n    }\n  } else {\n    for (var key in value) {\n      cb(key, value[key]);\n    }\n  }\n}\n\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n} // given a base object, returns it if unmodified, or return the changed cloned if modified\n\n\nfunction finalize(base, path, patches, inversePatches) {\n  if (isProxy(base)) {\n    var state = base[PROXY_STATE];\n\n    if (state.modified === true) {\n      if (state.finalized === true) return state.copy;\n      state.finalized = true;\n      var result = finalizeObject(useProxies ? state.copy : state.copy = shallowCopy(base), state, path, patches, inversePatches);\n      generatePatches(state, path, patches, inversePatches, state.base, result);\n      return result;\n    } else {\n      return state.base;\n    }\n  }\n\n  finalizeNonProxiedObject(base);\n  return base;\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n  var base = state.base;\n  each(copy, function (prop, value) {\n    if (value !== base[prop]) {\n      // if there was an assignment on this property, we don't need to generate\n      // patches for the subtree\n      var _generatePatches = patches && !has(state.assigned, prop);\n\n      copy[prop] = finalize(value, _generatePatches && path.concat(prop), _generatePatches && patches, inversePatches);\n    }\n  });\n  return freeze(copy);\n}\n\nfunction finalizeNonProxiedObject(parent) {\n  // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n  // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n  if (!isProxyable(parent)) return;\n  if (Object.isFrozen(parent)) return;\n  each(parent, function (i, child) {\n    if (isProxy(child)) {\n      parent[i] = finalize(child);\n    } else finalizeNonProxiedObject(child);\n  });\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n} // @ts-check\n\n\nvar proxies = null;\nvar objectTraps = {\n  get: get$1,\n  has: function has$$1(target, prop) {\n    return prop in source(target);\n  },\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source(target));\n  },\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n  defineProperty: defineProperty$1,\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Immer does not support `setPrototypeOf()`.\");\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) throw new Error(\"Immer does not support deleting properties from arrays: \" + prop);\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) throw new Error(\"Immer does not support setting non-numeric properties on arrays: \" + prop);\n  return objectTraps.set.call(this, state[0], prop, value);\n};\n\nfunction createState(parent, base) {\n  return {\n    modified: false,\n    // this tree is modified (either this object or one of it's children)\n    assigned: {},\n    // true: value was assigned to these props, false: was removed\n    finalized: false,\n    parent: parent,\n    base: base,\n    copy: undefined,\n    proxies: {}\n  };\n}\n\nfunction source(state) {\n  return state.modified === true ? state.copy : state.base;\n}\n\nfunction get$1(state, prop) {\n  if (prop === PROXY_STATE) return state;\n\n  if (state.modified) {\n    var value = state.copy[prop];\n    if (value === state.base[prop] && isProxyable(value)) // only create proxy if it is not yet a proxy, and not a new object\n      // (new objects don't need proxying, they will be processed in finalize anyway)\n      return state.copy[prop] = createProxy(state, value);\n    return value;\n  } else {\n    if (has(state.proxies, prop)) return state.proxies[prop];\n    var _value = state.base[prop];\n    if (!isProxy(_value) && isProxyable(_value)) return state.proxies[prop] = createProxy(state, _value);\n    return _value;\n  }\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be proxies, but falsy values are never proxies.\n    var isUnchanged = value ? is(state.base[prop], value) || value === state.proxies[prop] : is(state.base[prop], value) && prop in state.base;\n    if (isUnchanged) return true;\n    markChanged(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  state.assigned[prop] = false;\n  markChanged(state);\n  delete state.copy[prop];\n  return true;\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = state.modified ? state.copy : has(state.proxies, prop) ? state.proxies : state.base;\n  var descriptor = Reflect.getOwnPropertyDescriptor(owner, prop);\n  if (descriptor && !(Array.isArray(owner) && prop === \"length\")) descriptor.configurable = true;\n  return descriptor;\n}\n\nfunction defineProperty$1() {\n  throw new Error(\"Immer does not support defining properties on draft objects.\");\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = shallowCopy(state.base); // copy the proxies over the base-copy\n\n    assign(state.copy, state.proxies); // yup that works for arrays as well\n\n    if (state.parent) markChanged(state.parent);\n  }\n} // creates a proxy for plain objects / arrays\n\n\nfunction createProxy(parentState, base) {\n  if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\");\n  var state = createState(parentState, base);\n  var proxy = Array.isArray(base) ? Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  proxies.push(proxy);\n  return proxy.proxy;\n}\n\nfunction produceProxy(baseState, producer, patchListener) {\n  var previousProxies = proxies;\n  proxies = [];\n  var patches = patchListener && [];\n  var inversePatches = patchListener && [];\n\n  try {\n    // create proxy for root\n    var rootProxy = createProxy(undefined, baseState); // execute the producer function\n\n    var returnValue = producer.call(rootProxy, rootProxy); // and finalize the modified proxy\n\n    var result = void 0; // check whether the draft was modified and/or a value was returned\n\n    if (returnValue !== undefined && returnValue !== rootProxy) {\n      // something was returned, and it wasn't the proxy itself\n      if (rootProxy[PROXY_STATE].modified) throw new Error(RETURNED_AND_MODIFIED_ERROR); // we need to finalize the return value in case it's a subset of the draft\n\n      result = finalize(returnValue);\n\n      if (patches) {\n        patches.push({\n          op: \"replace\",\n          path: [],\n          value: result\n        });\n        inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: baseState\n        });\n      }\n    } else {\n      result = finalize(rootProxy, [], patches, inversePatches);\n    } // revoke all proxies\n\n\n    each(proxies, function (_, p) {\n      return p.revoke();\n    });\n    patchListener && patchListener(patches, inversePatches);\n    return result;\n  } finally {\n    proxies = previousProxies;\n  }\n} // @ts-check\n\n\nvar descriptors = {};\nvar states = null;\n\nfunction createState$1(parent, proxy, base) {\n  return {\n    modified: false,\n    assigned: {},\n    // true: value was assigned to these props, false: was removed\n    hasCopy: false,\n    parent: parent,\n    base: base,\n    proxy: proxy,\n    copy: undefined,\n    finished: false,\n    finalizing: false,\n    finalized: false\n  };\n}\n\nfunction source$1(state) {\n  return state.hasCopy ? state.copy : state.base;\n}\n\nfunction _get(state, prop) {\n  assertUnfinished(state);\n  var value = source$1(state)[prop];\n\n  if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n    // only create a proxy if the value is proxyable, and the value was in the base state\n    // if it wasn't in the base state, the object is already modified and we will process it in finalize\n    prepareCopy(state);\n    return state.copy[prop] = createProxy$1(state, value);\n  }\n\n  return value;\n}\n\nfunction _set(state, prop, value) {\n  assertUnfinished(state);\n  state.assigned[prop] = true; // optimization; skip this if there is no listener\n\n  if (!state.modified) {\n    if (is(source$1(state)[prop], value)) return;\n    markChanged$1(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) markChanged$1(state.parent);\n  }\n}\n\nfunction prepareCopy(state) {\n  if (state.hasCopy) return;\n  state.hasCopy = true;\n  state.copy = shallowCopy(state.base);\n} // creates a proxy for plain objects / arrays\n\n\nfunction createProxy$1(parent, base) {\n  var proxy = shallowCopy(base);\n  each(base, function (i) {\n    Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i));\n  });\n  var state = createState$1(parent, proxy, base);\n  createHiddenProperty(proxy, PROXY_STATE, state);\n  states.push(state);\n  return proxy;\n}\n\nfunction createPropertyProxy(prop) {\n  return descriptors[prop] || (descriptors[prop] = {\n    configurable: true,\n    enumerable: true,\n    get: function get$$1() {\n      return _get(this[PROXY_STATE], prop);\n    },\n    set: function set$$1(value) {\n      _set(this[PROXY_STATE], prop, value);\n    }\n  });\n}\n\nfunction assertUnfinished(state) {\n  if (state.finished === true) throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(state.copy || state.base));\n} // this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\n\n\nfunction markChangesSweep() {\n  // intentionally we process the proxies in reverse order;\n  // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n  // reverse order of proxy creation approximates this\n  for (var i = states.length - 1; i >= 0; i--) {\n    var state = states[i];\n\n    if (state.modified === false) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) markChanged$1(state);\n      } else if (hasObjectChanges(state)) markChanged$1(state);\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") return;\n  var state = object[PROXY_STATE];\n  if (!state) return;\n  var proxy = state.proxy,\n      base = state.base,\n      assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(proxy).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged$1(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(proxy[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (proxy[key] === undefined && !has(proxy, key)) {\n        assigned[key] = false;\n        markChanged$1(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged$1(state);\n    assigned.length = true;\n\n    if (proxy.length < base.length) {\n      for (var i = proxy.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var _i = base.length; _i < proxy.length; _i++) {\n        assigned[_i] = true;\n      }\n    }\n\n    for (var _i2 = 0; _i2 < proxy.length; _i2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[_i2] === undefined) markChangesRecursively(proxy[_i2]);\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      proxy = state.proxy; // Search for added keys. Start at the back, because non-numeric keys\n  // are ordered by time of definition on the object.\n\n  var keys = Object.keys(proxy);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (base[keys[i]] === undefined && !has(base, keys[i])) {\n      return true;\n    }\n  } // Since no keys have been added, we can compare lengths to know if an\n  // object has been deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var proxy = state.proxy;\n  if (proxy.length !== state.base.length) return true; // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) return true; // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction produceEs5(baseState, producer, patchListener) {\n  var prevStates = states;\n  states = [];\n  var patches = patchListener && [];\n  var inversePatches = patchListener && [];\n\n  try {\n    // create proxy for root\n    var rootProxy = createProxy$1(undefined, baseState); // execute the thunk\n\n    var returnValue = producer.call(rootProxy, rootProxy); // and finalize the modified proxy\n\n    each(states, function (_, state) {\n      state.finalizing = true;\n    });\n    var result = void 0; // check whether the draft was modified and/or a value was returned\n\n    if (returnValue !== undefined && returnValue !== rootProxy) {\n      // something was returned, and it wasn't the proxy itself\n      if (rootProxy[PROXY_STATE].modified) throw new Error(RETURNED_AND_MODIFIED_ERROR);\n      result = finalize(returnValue);\n\n      if (patches) {\n        patches.push({\n          op: \"replace\",\n          path: [],\n          value: result\n        });\n        inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: baseState\n        });\n      }\n    } else {\n      if (patchListener) markChangesRecursively(rootProxy);\n      markChangesSweep(); // this one is more efficient if we don't need to know which attributes have changed\n\n      result = finalize(rootProxy, [], patches, inversePatches);\n    } // make sure all proxies become unusable\n\n\n    each(states, function (_, state) {\n      state.finished = true;\n    });\n    patchListener && patchListener(patches, inversePatches);\n    return result;\n  } finally {\n    states = prevStates;\n  }\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the base state if nothing was modified\n */\n\n\nfunction produce(baseState, producer, patchListener) {\n  // prettier-ignore\n  if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length); // curried invocation\n\n  if (typeof baseState === \"function\" && typeof producer !== \"function\") {\n    var initialState = producer;\n    var recipe = baseState;\n    return function () {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var currentState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n      return produce(currentState, function (draft) {\n        return recipe.call.apply(recipe, [draft, draft].concat(args));\n      });\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\");\n    if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\");\n  } // avoid proxying anything except plain objects and arrays\n\n  if (!isProxyable(baseState)) {\n    var returnValue = producer(baseState);\n    return returnValue === undefined ? baseState : normalizeResult(returnValue);\n  } // See #100, don't nest producers\n\n\n  if (isProxy(baseState)) {\n    var _returnValue = producer.call(baseState, baseState);\n\n    return _returnValue === undefined ? baseState : normalizeResult(_returnValue);\n  }\n\n  return normalizeResult(getUseProxies() ? produceProxy(baseState, producer, patchListener) : produceEs5(baseState, producer, patchListener));\n}\n\nfunction normalizeResult(result) {\n  return result === NOTHING ? undefined : result;\n}\n\nvar applyPatches$1 = produce(applyPatches);\nvar nothing = NOTHING;\nexport { produce, applyPatches$1 as applyPatches, nothing, setAutoFreeze, setUseProxies, original, isProxy as isDraft };\nexport default produce;"],"sourceRoot":""}